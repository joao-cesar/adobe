<!DOCTYPE html>
<!--
	NOTES:
	1. All tokens are represented by '$' sign in the template.
	2. You can write your code only wherever mentioned.
	3. All occurrences of existing tokens will be replaced by their appropriate values.
	4. Blank lines will be removed automatically.
	5. Remove unnecessary comments before creating your template.
-->
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="authoring-tool" content="Adobe_Animate_CC">
<title>index</title>
<!-- write your code here -->
<style>
	:root
	{
		--bg-color: #1F1F1F;
	}
	.loading
	{
		display: flex;
		flex-direction: column;
		align-items: center;
		position: absolute;
		top: calc(50% - 50px);
		left: 50%;
		transform: translate(-50%, -50%);
	}
	.loading img
	{
		transform: scale(0.5);
	}
	.progress
	{
		position: relative;
		width: 160px;
		height: 24px;
		border: 1px solid white;
		background-color: transparent;
		border-radius: 12px;
	}
    progress::-moz-progress-bar
    {      
        border: 1px solid white;
		background-color: transparent;
		border-radius: 12px;
    }
    progress::-webkit-progress-bar
    {
        border: 1px solid white;
		background-color: transparent;
		border-radius: 12px;
    }
    progress::-webkit-progress-value
    {
        border: none;
        background-color: white;
		border-radius: 12px;
    }
    progress::-webkit-progress-value
    {
        border: none;
        background-color: white;
		border-radius: 12px;
    }
	progress:after
	{
		position: absolute;
  		content: attr(value)'%';
		color: white;
		top: 30px;
		left: 50%;
		transform: translateX(-50%);
		font-family: "Passion One Regular", sans-serif;
		font-weight: bold;
		font-size: 1.5rem;
		letter-spacing: 3px;
	}
</style>
<script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
<script>
function LoadGFonts(families, comp) {				
	var lib=comp.getLibrary();				
	var googleObject = {type: "Google", loadedFonts: 0, totalFonts: families.length, callOnLoad: lib.gfontAvailable};				
	for(var i =0; i < families.length; i++)				
		isFontAvailable(gFontsFamilies[i], googleObject);				
}
function isFontAvailable(font, obj) {				
	var timeOut = 5000;				
	var delay = 200;				
	var interval = 0;				
	var timeElapsed = 0;				
	function checkFont() {				
		var node = document.createElement("span");				
		node.innerHTML = "giItT1WQy@!-/#";				
		node.style.position      = "absolute";				
		node.style.left          = "-1000px";				
		node.style.top           = "-1000px";				
		node.style.fontSize      = "300px";				
		node.style.fontFamily    = "sans-serif";				
		node.style.fontVariant   = "normal";				
		node.style.fontStyle     = "normal";				
		node.style.fontWeight    = "normal";				
		node.style.letterSpacing = "0";				
		document.body.appendChild(node);				
		var width = node.offsetWidth;				
		node.style.fontFamily = font+","+node.style.fontFamily;				
		var returnVal = false;				
		if((node && node.offsetWidth != width) || timeElapsed >=timeOut) {				
			obj.loadedFonts++;				
			if(interval)				
				clearInterval(interval);				
			obj.callOnLoad(font, obj.totalFonts);				
			returnVal = true;				
		}				
		if(node) {				
			node.parentNode.removeChild(node);				
			node = null;				
		}				
		timeElapsed += delay;				
		return returnVal;				
	}				
	if(!checkFont()) {				
		interval = setInterval(checkFont, delay);				
	}				
}
</script>
<script>
	var gFontsFamilies = ["Luckiest Guy"];
</script>
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Luckiest+Guy:regular&subset=latin">
<script src="index.js?1636048997871"></script>
<script>
// Global Scripts
	(function()
{
	class Regards
	{
		static setup(props)
		{
			Regards.lib = props.lib;			
			Regards.root = props.root;
			Regards.stage = Regards.root.stage;
			Regards.canvas = Regards.stage.canvas;
			createjs.Touch.enable(Regards.stage, true, false);
			Regards.stage.mouseMoveOutside = true;
			Regards.stage.preventSelection = false;
			Display.setup();
			createjs.Ticker.timingMode = createjs.Ticker.RAF;
			Regards.root.on("mousedown", Regards.mouseDownHandler);
			window.addEventListener("resize", Regards.resizeHandler);
			if (props.showFPS)
				Regards.addFPSText();
		}
		static addFPSText()
		{
			const fpsLabel = new createjs.Text("-- fps", "bold 18px Arial", "#FFF");
			fpsLabel.x = 10;
			fpsLabel.y = 10;
			Regards.root.addChild(fpsLabel);
			createjs.Ticker.on("tick", e => fpsLabel.text = Math.round(createjs.Ticker.getMeasuredFPS()) + " fps");
		}
		static debug(text)
		{
			if (Regards.debugText)
				Regards.debugText.text = text;
			else
			{
				Regards.debugText = new createjs.Text(text, "bold 18px Arial", "#FFF");
				Regards.debugText.x = 10;
				Regards.debugText.y = 50;
				Regards.root.addChild(Regards.debugText);
			}
		}
		static tickStart(callback)
		{
			Regards.stage.removeAllEventListeners("tickstart");
			Regards.stage.on("tickstart", callback, Regards.root, true);
		}
		static resizeHandler(e)
		{
			UI.resizeHandler(e);
			if (Regards.root.resizeHandler)
				Regards.root.resizeHandler(e);
		}
		static mouseDownHandler(e)
		{
			if (Regards.root.mouseDownHandler)
				Regards.root.mouseDownHandler(e);
		}
		static getMouseWheelDelta(e)
		{
			const evt = window.event || e;
			return Math.max(-1, Math.min(1, evt.wheelDelta || -evt.detail));
		}
		static isMobile()
		{
			return createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;
		}
		static changeBackgroundColor = function(canvasColor, animColor, documentColor)
		{
			canvas.style.backgroundColor = canvasColor;
			anim_container.style.backgroundColor = animColor;
			document.body.style.backgroundColor = documentColor;			
		};
	}
	class Calc
	{
		static clamp(value, min, max)
		{
			if (value < min)
				return min;
			if (value > max)
				return max;
			return value;
		}
		static randomRange(min, max)
		{
			return Math.random() * (max - min) + min;
		}
		static lerp(v1, v2, f)
		{
			 return f * v1 + (1 - f) * v2;
		}
		static distanceBetweenTwoPoints = function(x1, y1, x2, y2)
		{
			const dx = x1 - x2;
			const dy = y1 - y2;
			return Math.sqrt(dx * dx + dy * dy);
		}
		static angleBetweenTwoPoints = function(x1, y1, x2, y2)
		{
			return Math.atan2(y2 - y1, x2 - x1);
		}
		static degreesToRadians = function(degrees)
		{
			return degrees * Math.PI / 180;
		}
		static radiansToDegrees = function(radians)
		{
			return radians * 180 / Math.PI;
		}
		static rotationTo360(rotation)
		{
			return (rotation + 360) % 360;
		}
	}
	class Sound
	{
		static play(linkage, type, stopPrevious = true, props = {})
		{            
			if (stopPrevious && Sound.channels[type])
				Sound.channels[type].stop();
			Sound.channels[type] = createjs.Sound.play(linkage, props);
		};
	}
	class Basis
	{
		constructor(props)
		{
			this.target = props.target;
			this.callbacks = props.callBacks || {};
		}
	}
	class Display extends Basis
	{
		constructor(props)
		{
			super(props);
			if (props.tick)
				this.tick = createjs.Ticker.on("tick", this.tickHandler, this);
		}
		tickHandler(e)
		{			
			if (this.callbacks.tickHandler)
				this.callbacks.tickHandler(e, this);
		}
		remove()
		{
			const index = Body.children.indexOf(this);
			if (index > -1)
				Body.children.splice(index, 1);
			Display.remove(this.target);
			if (this.tick)
				createjs.Ticker.off("tick", this.tick);
		}
		static add(linkage, container, index)
		{
			return container.addChildAt(new Regards.lib[linkage](), index);
		}
		static remove(target)
		{
			target.removeAllEventListeners();
			createjs.Tween.removeTweens(target);
			target._off = true;
			target.parent.removeChild(target);
		}
		static setup()
		{
			Display.domContainers = [ Regards.canvas, anim_container, dom_overlay_container ];
			Display.w = Regards.lib.properties.width;
			Display.h = Regards.lib.properties.height;
			Display.pixelRatio = window.devicePixelRatio || 1;
			Display.fixText();
			Display.resizeHandler();
		}
		static resizeHandler(e)
		{
			Display.iW = window.innerWidth;
			Display.iH = window.innerHeight;
			Display.domContainers[0].width = Display.iW * Display.pixelRatio;			
			Display.domContainers[0].height = Display.iH * Display.pixelRatio;
			Display.domContainers.forEach(function(container)
			{				
				container.style.width = "100%";				
				container.style.height = "100%";
			});
			Regards.stage.scaleX = Display.pixelRatio;
			Regards.stage.scaleY = Display.pixelRatio;
			Regards.stage.tickOnUpdate = false;            
			Regards.stage.update();            
			Regards.stage.tickOnUpdate = true;
			Display.orientation = Display.iW > Display.iH ? "landscape" : "portrait";
			Display.scale = Math.max(window.innerWidth / Regards.lib.properties.width, window.innerHeight / Regards.lib.properties.height);
			if (Regards.root.resizeHandler)
				Regards.root.resizeHandler(e);
		}
		static getPointerPos(target)
		{
			return target.globalToLocal(Regards.stage.mouseX, Regards.stage.mouseY);
		}
		static fixText(lineHeightRatio = 0.14)
		{
			const chrome = navigator.userAgent.toLowerCase().indexOf("chrome") > -1;
			const firefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
			if ((chrome || firefox) && createjs)
			{
				createjs.Text.prototype._drawTextLine = function(ctx, text, y)
				{
					if (this.textBaseline === "top")
						y += (this.lineHeight || this.getMeasuredLineHeight()) * lineHeightRatio;
					ctx[this.outline ? "strokeText" : "fillText"](text, 0, y, this.maxWidth || 0xFFFF);
				};
			}
		}
		static getWidth(target)
		{
			if (target === Regards.root)
				return Display.iW;
			if (target instanceof createjs.Text)
				return target.getMeasuredWidth();
			if (target.getBounds())
				return target.getBounds().width;
			return target.nominalBounds.width * target.scaleX;
		}
		static getHeight(target)
		{
			if (target === Regards.root)
				return Display.iH;
			if (target instanceof createjs.Text)
				return target.getMeasuredHeight();
			if (target.getBounds())
				return target.getBounds().height;
			return target.nominalBounds.height * target.scaleY;
		}
		static getSize(target)
		{
			return { width: Display.getWidth(target), height: Display.getHeight(target) };
		}
		static cache(target, offsetX = 0, offsetY = 0, uncache = true)
		{
			let bounds;
			if (uncache)
				target.uncache();
			bounds = target.nominalBounds;
			bounds.width += offsetX;
			bounds.height += offsetY;
			target.cache(-offsetX, -offsetY, bounds.width * 2, bounds.height * 2, Display.scale);
		}
		static cacheMultiple(targets, offsetX = 0, offsetY = 0, uncache = true)
		{
			let i;
			for (i = targets.length - 1; i > -1; i--)
				Display.cache(targets[i], offsetX, offsetY, uncache);
		}
		static removeAll(container)
		{
			while(container.numChildren > 0)
				Display.remove(getChildAt(0));
		}
		static setNominalBounds(target, className)
		{
			Regards.lib[className].prototype.nominalBounds = { x: target.x, y: target.y, width: Regards.lib.properties.width, height: Regards.lib.properties.height };
		}
		static depthSort()
		{
			Regards.root.inGame.world.sortChildren(function(a, b)
			{
				if (Body.grounds.indexOf(a) > -1 || Body.grounds.indexOf(b) > -1)
					return 0;
				return a.y - b.y;
			});		
		}
	}
	class UI extends Display
	{
		constructor(props)
		{
			super(props);
		}
		static pos(target, ratioX = 1, ratioY = 1)
		{
			UI.posX(target, ratioX);
			UI.posY(target, ratioY);
		}
		static posX(target, ratio = 1)
		{
			target.x = Display.getWidth(target.parent) * ratio;
		}
		static posY(target, ratio = 1)
		{
			target.y = Display.getHeight(target.parent) * ratio;
		}
		static size(target, width, height)
		{
			UI.width(target, width, false);
			UI.height(target, height, false);
		}
		static width(target, width, keepAspectRatio = true)
		{
			target.scaleX = width / target.nominalBounds.width;
			if (keepAspectRatio)
				target.scaleY = target.scaleX;
		}
		static height(target, height, keepAspectRatio = true)
		{
			target.scaleY = height / target.nominalBounds.height;
			if (keepAspectRatio)
				target.scaleX = target.scaleY;
		}
		static fill(target, ratioX = 1, ratioY = 1)
		{
			UI.fillX(target, ratioX);
			UI.fillY(target, ratioY);
		}
		static fillX(target, ratio = 1)
		{
			target.scaleX = Display.getWidth(target.parent) * ratio / target.nominalBounds.width;
		}
		static fillY(target, ratio = 1)
		{
			target.scaleY = Display.getHeight(target.parent) * ratio / target.nominalBounds.height;
		}
		static fit(target)
		{
			const targetSize = Display.getSize(target);
			const parentSize = Display.getSize(target.parent);
			if (targetSize.width >= targetSize.height)
			{
				if (parentSize.width >= parentSize.height)
					UI.height(target, parentSize.height);
				else
					UI.width(target, parentSize.width);
			}				
			else
			{
				if (parentSize.width >= parentSize.height)
					UI.width(target, parentSize.width);
				else
					UI.height(target, parentSize.height);
			}
		}
		static offset(target, ratioX = 1, ratioY = 1, absoluteX = 0, absoluteY = 0)
		{
			UI.offsetX(target, ratioX, absoluteX);
			UI.offsetY(target, ratioY, absoluteY);
		}
		static offsetX(target, ratio = 1, absolute = 0)
		{
			target.x += Display.getWidth(target) * ratio + absolute;
		}
		static offsetY(target, ratio = 1, absolute = 0)
		{
			target.y += Display.getHeight(target) * ratio + absolute;
		}
		static clamp(target, props, min = Number.MIN_VALUE, max = Number.MAX_VALUE)
		{
			props.forEach(prop => target[prop] = Calc.clamp(target[prop], min, max));
		}
		static autoScale(target)
		{
			target.scaleX = target.scaleY = Regards.Display.scale;
		}
		static row(children, offset = 0, width = undefined)
		{
			if (!width)
				width = Display.getWidth(children[0]);
			children.forEach((child, index) =>
			{
				child.x = (width + offset) * index;
			});
		}
		static fitViewPort(target, className)
		{
			Display.setNominalBounds(target, className);
			if (Display.orientation === "landscape")
				UI.width(target, Display.iW);
			else
				UI.height(target, Display.iH);
			if (target.nominalBounds.height * target.scaleY < Display.iH)
				UI.height(target, Display.iH);
		}
	}
	class Gamepad extends UI
	{
		constructor(props)
		{
			super(props);
			this.keyForce = props.keyForce || 35;
			this.keys = {};
			window.addEventListener("keydown", this.keyDownHandler.bind(this));
			window.addEventListener("keyup", this.keyUpHandler.bind(this));
		}
		keyDownHandler(e)
		{
			this.keys[e.key] = true;
		}
		keyUpHandler(e)
		{
			delete this.keys[e.key];
		}
	}
	class DPad extends UI
	{
		constructor(props)
		{
			super(props);
			this.pressed = false;
			this.xRange = props.xRange || 60;
			this.yRange = props.yRange || 60;
			this.deltaX = 0;
			this.deltaY = 0;
			this.target.stage.on("stagemousedown", this.mouseDownHandler, this);
			this.target.stage.on("stagemouseup", this.pressUpHandler, this);
		}
		getDelta()
		{
			const pointerPos = Display.getPointerPos(this.target);
			this.deltaX = Calc.clamp(pointerPos.x, -this.xRange * 0.5, this.xRange * 0.5);
			this.deltaY = Calc.clamp(pointerPos.y, -this.yRange * 0.5, this.yRange * 0.5);			
		}
		mouseDownHandler(e)
		{			
			this.pointerPos = Display.getPointerPos(e.currentTarget);
			this.getDelta();
			this.pressed = true;
			if (this.callbacks.mouseDownHandler)
				this.callbacks.mouseDownHandler(e, this);
		}
		tickHandler(e)
		{
			if (this.pressed)
				this.getDelta();
			if (this.callbacks.tickHandler)
			{
				this.pointerPos = Display.getPointerPos(this.target.parent);
				this.callbacks.tickHandler(e, this);
			}				
		}
		pressUpHandler(e)
		{
			this.pressed = false;
			if (this.callbacks.pressUpHandler)
				this.callbacks.pressUpHandler(e, this);
		}
	}
	class Game extends Display
	{
		constructor(props)
		{
			super(props);
		}
	}
	class Camera extends Game
	{
		constructor(props)
		{
			super(props);
			this.follow = props.follow;
			this.ease = props.ease || 0.65;
			this.target.x = this.seekX();
			this.target.y = this.seekY();
		}
		seekX()
		{
			return -this.follow.x;
		}
		seekY()
		{
			return -this.follow.y;
		}
		tickHandler()
		{
			this.target.x = Calc.lerp(this.target.x, this.seekX(), this.ease);
			this.target.y = Calc.lerp(this.target.y, this.seekY(), this.ease);
		}
	}
	class Body extends Game
	{
		constructor(props)
		{
			super(props);
			Body.children.push(this);
			this.collidable = true;
			this.getPrevX();
			this.getPrevY();
		}
		tickHandler(e)
		{
			Display.depthSort();
			if (this.callbacks.tickHandler)
				this.callbacks.tickHandler(e, this);
			this.getPrevX();
			this.getPrevY();
		}
		getPrevX()
		{
			this.prevX = this.target.x;
		}
		getPrevY()
		{
			this.prevY = this.target.y;
		}
		passThrough(delay)
		{
			this.collidable = false;
			clearTimeout(this.passThroughTimeout);
			this.passThroughTimeout = setTimeout(() => this.collidable = true, delay);
		}
		circularCollision(body0, body1, radius, callback)
		{
			if (!this.collidable)
				return;
			if (Calc.distanceBetweenTwoPoints(body0.target.x, body0.target.y, body1.target.x, body1.target.y) < radius)
				callback(body0, body1);
		}
		shapeCollision(body0, body1, callback)
		{
			if (!this.collidable)
				return;
			const hit0 = body0.target.hit || body0.target;				
			const hit1 = body1.target.hit || body1.target;			
			const angle = Calc.angleBetweenTwoPoints(body0.prevX, body0.prevY, hit0.x, hit0.y);
			let point = hit0.localToLocal(0, 0, hit1);
			let hit = false;
			while (hit1.hitTest(point.x, point.y))
			{
				hit = true;
				hit0.x = hit0.x - 0.5 * Math.cos(angle);
				hit0.y = hit0.y - 0.5 * Math.sin(angle);
				point = hit0.localToLocal(0, 0, hit1);
			}
			if (callback && hit)
				callback(body0, body1);
		}
	}
	class StaticBody extends Body
	{
		constructor(props)
		{
			super(props);
		}
	}
	class DynamicBody extends Body
	{
		constructor(props)
		{
			super(props);
			this.vX = props.vX || 0;
			this.vY = props.vY || 0;
			this.minVX = props.minVX || 20;
			this.minVY = props.minVY || 20;
			this.friction = props.friction || 0.85;
		}
		moveX(delta)
		{
			this.vX *= this.friction;
			this.target.x += this.vX * delta * 0.001;
			if (Math.abs(this.vX) > 0 && Math.abs(this.vX) < this.minVX)
				this.vX = 0;
		}
		moveY(delta)
		{
			this.vY *= this.friction;
			this.target.y += this.vY * delta * 0.001;
			if (Math.abs(this.vY) > 0 && Math.abs(this.vY) < this.minVY)
				this.vY = 0;
		}
		tickHandler(e)
		{			
			this.moveX(e.delta);
			this.moveY(e.delta);
			Display.depthSort();
			if (this.callbacks.tickHandler)
				this.callbacks.tickHandler(e, this);
			this.getPrevX();
			this.getPrevY();
		}
	}
	class Player extends DynamicBody
	{
		constructor(props)
		{
			super(props);
			this.gamepad = props.gamepad;
			this.keys = props.keys || {};
		}
		keyX()
		{			
			if (this.gamepad.keys[this.keys.left])
				this.vX -= this.gamepad.keyForce;
			else if (this.gamepad.keys[this.keys.right])
				this.vX += this.gamepad.keyForce;	
		}
		keyY()
		{			
			if (this.gamepad.keys[this.keys.up])
				this.vY -= this.gamepad.keyForce;
			else if (this.gamepad.keys[this.keys.down])
				this.vY += this.gamepad.keyForce;
		}
		tickHandler(e)
		{
			this.keyX();
			this.keyY();
			this.moveX(e.delta);
			this.moveY(e.delta);
			Display.depthSort();
			if (this.callbacks.tickHandler)
				this.callbacks.tickHandler(e, this);
			this.getPrevX();
			this.getPrevY();
		}
	}
	class Warp extends StaticBody
	{
		constructor(props)
		{
			super(props);
			this.passenger = props.passenger;
			this.radius = props.radius;
			this.callback = props.callback;
			this.target.visible = false;
		}
		tickHandler()
		{
			this.circularCollision(this, this.passenger, this.radius, this.callback.bind(this));
		}
	}
	class Collectible extends StaticBody
	{
		constructor(props)
		{
			super(props);
			this.collector = props.collector;
			this.radius = props.radius;
			this.callback = props.callback;
		}
		tickHandler()
		{
			this.circularCollision(this, this.collector, this.radius, this.callback.bind(this));
			Display.depthSort();
		}
	}
	window.regards = Regards;
	window.regards.Calc = Calc;
	window.regards.Sound = Sound;
	window.regards.Basis = Basis;
	window.regards.Display = Display;
	window.regards.UI = UI;
	window.regards.Gamepad = Gamepad;
	window.regards.DPad = DPad;
	window.regards.Game = Game;
	window.regards.Camera = Camera;
	window.regards.Body = Body;
	window.regards.StaticBody = StaticBody;
	window.regards.DynamicBody = DynamicBody;
	window.regards.Player = Player;
	window.regards.Warp = Warp;
	window.regards.Collectible = Collectible;
	Sound.channels = {};
	Body.children = [];
	Body.grounds = [];
}());</script>
<script>
var canvas, stage, exportRoot, anim_container, dom_overlay_container, fnStartAnimation;
function init() {
	canvas = document.getElementById("canvas");
	anim_container = document.getElementById("animation_container");
	dom_overlay_container = document.getElementById("dom_overlay_container");
	var comp=AdobeAn.getComposition("41F9A218C3BC4D4EA655CB0DC51F4EEE");
	var lib=comp.getLibrary();
	try {
		if(!(typeof gFontsFamilies === 'undefined' || gFontsFamilies === null))
			LoadGFonts(gFontsFamilies, comp);		
		if(!(typeof totalTypekitFonts === 'undefined' || totalTypekitFonts === null)) {			
			var typekitObject = {type: 'Typekit', loadedFonts: 0, totalFonts: totalTypekitFonts, callOnLoad: lib.tfontAvailable};		
			Typekit.load({
			async: true,
			'fontactive': function(family) {
				isFontAvailable(family, typekitObject);
				}
			});
		}
	} catch(e) {};
	var loader = new createjs.LoadQueue(false);
	loader.installPlugin(createjs.Sound);
	loader.addEventListener("fileload", function(evt){handleFileLoad(evt,comp)});
	loader.addEventListener("complete", function(evt){handleComplete(evt,comp)});
	var lib=comp.getLibrary();
	loader.loadManifest(lib.properties.manifest);
	var progressBar = document.querySelector(".progress");
	loader.addEventListener("progress", function(evt)
	{
		progressBar.value = Math.round(evt.progress * 100);
	});
}
function handleFileLoad(evt, comp) {
	var images=comp.getImages();	
	if (evt && (evt.item.type == "image")) { images[evt.item.id] = evt.result; }	
}
function handleComplete(evt,comp) {
	//This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
	var lib=comp.getLibrary();
	var ss=comp.getSpriteSheet();
	var queue = evt.target;
	var ssMetadata = lib.ssMetadata;
	for(i=0; i<ssMetadata.length; i++) {
		ss[ssMetadata[i].name] = new createjs.SpriteSheet( {"images": [queue.getResult(ssMetadata[i].name)], "frames": ssMetadata[i].frames} )
	}
	exportRoot = new lib.not_so_dungeon();
	stage = new lib.Stage(canvas);
	stage.enableMouseOver();	
	//Registers the "tick" event listener.
	fnStartAnimation = function() {
		stage.addChild(exportRoot);
		createjs.Ticker.framerate = lib.properties.fps;
		createjs.Ticker.addEventListener("tick", stage);
	}	    
	//Code to support hidpi screens and responsive scaling.
	AdobeAn.makeResponsive(false,'both',false,1,[canvas,anim_container,dom_overlay_container]);	
	AdobeAn.compositionLoaded(lib.properties.id);
	fnStartAnimation();
}
function playSound(id, loop, offset) {
	return createjs.Sound.play(id, {'interrupt':createjs.Sound.INTERRUPT_EARLY, 'loop': loop, 'offset': offset});}
</script>
<!-- write your code here -->
</head>
<body onload="init();" style="margin:0px; background-color: var(--bg-color);">
	<div id="animation_container" style="display: none; background-color: var(--bg-color); width:960px; height:540px">
		<canvas id="canvas" width="960" height="540" style="position: absolute; display: block; background-color: var(--bg-color);"></canvas>
		<div id="dom_overlay_container" style="pointer-events:none; overflow:hidden; width:960px; height:540px; position: absolute; left: 0px; top: 0px; display: block;">
		</div>
	</div>
	<div class="loading">
		<progress class="progress" value="32" max="100"></progress>
	</div>
</body>
</html>